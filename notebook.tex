\documentclass[8pt,a4paper,landscape,oneside]{amsart}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{multicol}
\usepackage{fancyhdr}

%\usepackage{booktabs}
%\usepackage{caption}
%\usepackage{color}
%\usepackage{float}
\usepackage{fullpage}
%\usepackage{subcaption}
%\usepackage[scaled]{beramono}
\usepackage{titling}
%\usepackage{datetime}
%\usepackage{enumitem}
%\usepackage{bm}
\usepackage{fontspec}

% Minted
\usepackage{minted}
\newcommand{\code}[1]{\inputminted[fontsize=\normalsize,baselinestretch=1]{java}{code/#1}}

\newcommand{\bigO}{\mathcal{O}}

% Define flip table command, may only work on windows
\newfontfamily{\fliptablefont}{Arial Unicode MS}
\DeclareRobustCommand{\fliptable}{{\fliptablefont ┻━┻ ︵ ＼( °□° )／ ︵ ┻━┻ }}

\pagestyle{fancy}
\lhead{\fliptable - Lund University}
\rhead{\thepage}
\cfoot{}
\setlength{\headheight}{15.2pt}
\setlength{\droptitle}{-20pt}
\posttitle{\par\end{center}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\begin{document}

\begin{multicols*}{3}
%\maketitle
\thispagestyle{fancy}
\vspace{-3em}

\tableofcontents
\section{Code Templates}
  \subsection{KattIO}
  \code{Kattio.java}
  
  
\section{Search \& Sort}
  \subsection{Binary Search}
  Time complexity is $\bigO(n \log(n))$ and space complexity is $\bigO(1)$.
  \code{Structures/BinarySearch.java}
  \subsection{Sorting}
  Time complexity is $\bigO(n \log(n))$ for both algorithms and space complexity is $\bigO(\log(n))$.
  \begin{itemize}
  \item \texttt{Collections.sort()} uses Merge Sort
  \item \texttt{Arrays.sort()} uses Quick Sort
  \end{itemize}
  
  \subsection{Quick Select}
  Time complexity is $\bigO(n)$ on average and $\bigO(n^2)$ in the worst case. The space complexity is $\bigO(\log(n))$.
  \code{Structures/QuickSelect.java}
  
  \subsection{Knuth-Morris-Pratt Algorithm}
  Time complexity is $\bigO(n)$ and space complexity is $\bigO(\log(n))$. Good when the alphabet is small (around 4-5 characters).
  \code{Structures/KMP.java}
  
  \subsection{Z-Array Algorithm}
  Time complexity is $\bigO(n)$ and space complexity is $\bigO(n)$. Good when the alphabet is large.
  \code{Structures/ZArray.java}
  
  
\section{Data Structures}
  \subsection{Fenwick tree}
  Time complexity is $\bigO(\log(n))$ for all operations and space complexity is $\bigO(1)$.
  \code{Structures/Fenwick.java}
  
  \subsection{Segment Tree}
  Time complexity is $\bigO(n)$ for construction and $\bigO(\log(n))$ for all operations and space complexity is $\bigO(n)$.
  \code{Structures/SegmentTreeRMQ.java}
  
  \subsection{Monotone Queue}
  Time complexity is amortized $\bigO(1)$ for all operations and space complexity is $\bigO(w)$, where $w$ is the size of the sliding window.
  \code{Structures/MinMonoQueue.java}
  
  \subsection{Union-Find}
  Time complexity is amortized $\bigO(\log^*{n})$ for all operations and space complexity is $\bigO(1)$.
  \code{Structures/UnionFind.java}
  
  \subsection{Suffix Array}
  Time complexity for construction is $\bigO(n\log{n}\log{n})$ and space complexity is $\bigO(n)$.
  \code{Structures/SuffixArray.java}
  
  \subsection{Treap}
  Time complexity for construction is $\bigO(n\log{n}\log{n})$, for all operations $\bigO(\log{n})$ and space complexity is $\bigO(n)$.
  \code{Structures/Treap.java}
  
  
\section{Graph Algorithms}
  \subsection{Graph definition}
  This graph class is used for the graph algorithms. Not all attributes of the classes are needed in all problems.
  \code{Graphs/Graph.java}
  
  \subsection{Dijsktra's Algorithm}
  Time complexity is $\bigO(|E| \log{|V|})$ and space complexity is $\bigO(|V|)$.
  \code{Graphs/Dijkstras.java}
  
  \subsection{Bellman-Ford Algorithm}
  Time complexity is $\bigO(|E||V|)$ and space complexity is $\bigO(|V|)$.
  \code{Graphs/BellmanFord.java}
  
  \subsection{Floyd-Warshall Algorithm}
  Time complexity is $\bigO(|V|^3)$ and space complexity is $\bigO(|V|^2)$.
  \code{Graphs/FloydWarshall.java}
  
  \subsection{Prim's Algorithm}
  Time complexity is $\bigO(|E| \log{|V|})$ and space complexity is $\bigO(|V|)$.
  \code{Graphs/MST.java}
  
  \subsection{Topological Sort}
  Time complexity is $\bigO(|E| + |V|)$ and space complexity is $\bigO(|V|)$. You need to pop the resulting stack to get the nodes in the correct order, \textit{do not} loop over it/convert to list since that results in the reverse order. Running this on a graph with cycles yields an incorrect result.
  \code{Graphs/TopologicalSort.java}
  
  \subsection{Network Flow/Min Cut}
  Time complexity is $\bigO(|V||E|^2)$ and space complexity is $\bigO(|V|+|E|)$. Solves both max flow and min cut. If the graph is very large this can be improved to $\bigO(|E|^2 \log{C})$ (where C is the maximum flow). Find $\Delta$, the largest POT that is smaller than the largest flow out of $s$. Run the algorithm but only allow edges with a capacity of at least $\Delta$. When there are no more paths between $s$ and $t$ let $\Delta = \Delta / 2$ and repeat until $\Delta < 0$.
  \code{Graphs/NetworkFlow.java}
  
  \subsection{Hopcroft-Carp Algorithm}
  Time complexity is $\bigO(|E|\sqrt{|V|})$ and space complexity is $\bigO(|V|)$. Gives both a maximum bipartite matching and a minimum vertex cover. Can be converted to Maximum Independent Set by selecting all vertices not in the vertex cover.
  \code{Graphs/HopcroftCarp.java}
  
  
\section{Geometry}
  \subsection{Graham Scan}
  Time complexity is $\bigO(n\log{n})$ and space complexity is $\bigO(n)$.
  \code{Geometry/GrahamScan.java}
  
\section{Dynamic Programing}
  \subsection{Knapsack 1/0}
  Given a set of items each with a value $v_i$ and a weight $w_i$ you want to maximize the value while limited by a total weight $W$. The following recursion relation solves the problem in $\bigO(nW)$:
  \[
  Opt(i,w) = \begin{cases}
  0 & \text{if } i=0 \\
  Opt(i-1,W) & \text{if } W<w_i \\
  \begin{aligned}[t]\arraycolsep=0pt
    \max\lbrace &
      Opt(i-1,W), \\ &
      Opt(i-1,W-w_i) + v_i \rbrace
  \end{aligned} & \text{if } W \geq w_i
  \end{cases}
  \]
  The answer is $Opt(n, W)$.
  
  \subsection{Knapsack Unbounded}
  The same problem as above but with an unlimited amount of each item. The following recursion relation solves the problem in $\bigO(nW)$:
  \[
  Opt(i,w) = \begin{cases}
  0 & \text{if } W=0 \\
  \max\limits_{w_i \leq W} \lbrace Opt(W-w_i) + v_i \rbrace & \text{otherwise}
  \end{cases}
  \]
  The answer is $Opt(n, W)$.
  
  \subsection{Subset Sum}
  Given a set of values you want to select a subset that sum to $W$. This is solved by knapsack by letting $w_i = v_i$ and checking if $Opt(n, W) = W$.
  
  \subsection{Minimum Partition Distance}
  Given a set of $n$ numbers $s_i$ you want to split them into two sets $A$ and $B$ such that $|\sum a_i| - |\sum b_i|$ is minimized. The following recursion relation solves the problem in $\bigO(nS)$ (where $S$ is the sum of all numbers):
  \[
  Opt(i,d) = \begin{cases}
  d & \text{if } i=0 \\
  \begin{aligned}[t]\arraycolsep=0pt
    \arg\min\limits_x(x \in \{ & Opt(i-1,d-s_i), \\ &
    Opt(i-1,d+s_i)\} : |x|)
  \end{aligned} & \text{if } i > 0 \\
  
  \end{cases}
  \]
  The answer is $Opt(n, 0)$.
  
  \subsection{Edit distance}
  Given two strings $a$ and $b$ of length $m$ and $n$ find the minimum edit distance using penalties $p_m$ for mismatches and $p_s$ when padding with spaces. The following recursion relation solves the problem in $\bigO(mn)$:
  \[
  Opt(i,j) = \begin{cases}
  j*p_s & \text{if } i=0 \\
  i*p_s & \text{if } j=0 \\
  Opt(i-1,j-1) & \text{if } a_i=b_j \\
  \begin{aligned}[t]\arraycolsep=0pt
    \min\lbrace &
      Opt(i-1,j-1) + p_m, \\ &
      Opt(i-1,j) + p_s, \\ & 
      Opt(i,j-1) + p_s \rbrace
  \end{aligned} & \text{if } a_i\neq b_j
  \end{cases}
  \]
  The answer is $Opt(m,n)$. Example: ED("ABC", "ACD") = 2 ("ABC-" vs. "A-CD") where $p_m = p_s = 1$.
  
  \subsection{Longest Common Subsequence}
  Related to edit distance, you want to compute the longest common subsequence of two strings $a$ and $b$ of length $m$ and $n$. The result of the algorithm is the string itself ($\frown$ appends to the result). The following recursion relation solves the problem in $\bigO(mn)$:
  \[
  Opt(i,j) = \begin{cases}
  0 & \text{if } i=0 \text{ or } j=0 \\
  Opt(i-1,j-1) \frown a_i & \text{if } a_i=b_j \\
  \begin{aligned}[t]\arraycolsep=0pt
    \mathrm{longest}\lbrace &
      Opt(i-1,j), \\ & 
      Opt(i,j-1) \rbrace
  \end{aligned} & \text{if } a_i\neq b_j
  \end{cases}
  \]
  The answer is $Opt(m,n)$. Example: LCS("ABCD", "A-B-D-C") = "ABD".
  
  \subsection{Longest Increasing Subsequence}
  Time complexity is $\bigO(|n|\log(n))$ and space complexity is $\bigO(n)$.
  \code{DP/LongestIncreasingSubsequence.java}
        
        
\section{Checking for errors}
  \subsection{Wrong Answer}
    \begin{itemize}
    \item Test minimal input
    \item Integer overflow?
    \item Double precision too low?
    \item Reread the problem statement
    \item Look for edge-cases
    \item Start creating small testcases
    \end{itemize}
  \subsection{Time Limit Exceeded}
    \begin{itemize}
    \item Is the time complexity checked?
    \item Is the output efficient?
    \item If written in python, rewrite in java?
    \item Can we apply DP anywhere?
    \item Create worst case input
    \end{itemize}
  \subsection{Runtime Error}
    \begin{itemize}
    \item Stack overflow?
    \item Index out of bounds?
    \item Division by $0$?
    \item Concurrent modification?
    \end{itemize}
  \subsection{Memory Limit Exceeded}
    \begin{itemize}
    \item Create objects outside recursive function
    \item Convert recursive functions to iterative with your own stack
    \end{itemize}
        
        
\section{Running time}
The following table contains the number of elements that can be processed per second given the algorithm complexity in $n$.
\begin{center}
\begin{tabular}{lr}
Alg. Complexity & Input size/s \\ \hline
$\bigO(\log^*{n})$   & $\rightarrow \infty$ \\
$\bigO(\log{n})$     & 2 \textasciicircum 100 000 000 \\
$\bigO(n)$           & 100 000 000 \\
$\bigO(n*\log{n})$   & 4 500 000 \\
$\bigO(n*\log{n}*\log{n})$ & 300 000 \\
$\bigO(n^2)$         & 10 000 \\
$\bigO(n^2*\log{n})$ & 3 000 \\
$\bigO(n^3)$         & 450 \\
$\bigO(2^n)$         & 26.5 \\
$\bigO(3^n)$         & 16.5 \\
$\bigO(n!)$          & 10
\end{tabular}
\end{center}



\end{multicols*}
\end{document}
