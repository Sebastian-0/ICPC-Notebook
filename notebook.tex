\documentclass[8pt,a4paper,landscape,oneside]{amsart}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{multicol}
\usepackage{fancyhdr}

%\usepackage{booktabs}
%\usepackage{caption}
%\usepackage{color}
%\usepackage{float}
\usepackage{fullpage}
%\usepackage{subcaption}
%\usepackage[scaled]{beramono}
\usepackage{titling}
%\usepackage{datetime}
%\usepackage{enumitem}
%\usepackage{bm}

% Minted
\usepackage{minted}
\newcommand{\code}[1]{\inputminted[fontsize=\normalsize,baselinestretch=1]{java}{code/#1}}

\newcommand{\bigO}{\mathcal{O}}

\pagestyle{fancy}
\lhead{Flip the tables - Lund University}
\rhead{\thepage}
\cfoot{}
\setlength{\headheight}{15.2pt}
\setlength{\droptitle}{-20pt}
\posttitle{\par\end{center}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\begin{document}

\begin{multicols*}{3}
%\maketitle
\thispagestyle{fancy}
\vspace{-3em}

\tableofcontents
\section{Code Templates}
  \subsection{KattIO}
  \code{Kattio.java}
  
  
\section{Data Structures}
  \subsection{Binary Search}
  Time complexity is $\bigO(n \log(n))$ and space complexity is $\bigO(1)$.
  \code{Structures/BinarySearch.java}
  \subsection{Sorting}
  Time complexity is $\bigO(n \log(n))$ for both algorithms and space complexity is $\bigO(\log(n))$.
  \begin{itemize}
  \item \texttt{Collections.sort()} uses Merge Sort
  \item \texttt{Arrays.sort()} uses Quick Sort
  \end{itemize}
  
  \subsection{Quick Select}
  Time complexity is $\bigO(n)$ on average and $\bigO(n^2)$ in the worst case. The space complexity is $\bigO(\log(n))$.
  \code{Structures/QuickSelect.java}
  
  \subsection{Knuth-Morris-Pratt Algorithm}
  Time complexity is $\bigO(n)$ and space complexity is $\bigO(\log(n))$.
  \code{Structures/KMP.java}
  
  \subsection{Fenwick tree}
  Time complexity is $\bigO(\log(n))$ for all operations and space complexity is $\bigO(1)$.
  \code{Structures/Fenwick.java}
  
  
\section{Graph Algorithms}
  \subsection{Graph definition}
  This graph class is used for the graph algorithms. Not all attributes of the classes are needed in all problems.
  \code{Graphs/Graph.java}  
  \subsection{Dijsktra's Algorithm}
  Time complexity is $\bigO(|E| \log{|V|})$ and space complexity is $\bigO(|V|)$.
  \code{Graphs/Dijkstras.java}
  
  \subsection{Bellman-Ford Algorithm}
  Time complexity is $\bigO(|E||V|)$ and space complexity is $\bigO(|V|)$.
  \code{Graphs/BellmanFord.java}
  
  \subsection{Floyd-Warshall Algorithm}
  Time complexity is $\bigO(|V|^3)$ and space complexity is $\bigO(|V|^2)$.
  \code{Graphs/FloydWarshall.java}
  
  \subsection{Prim's Algorithm}
  Time complexity is $\bigO(|E| \log{|V|})$ and space complexity is $\bigO(|V|)$. If you want to have the resulting tree, add a parent node and a list of child nodes to all nodes. Set the parent when you update the cost of another node, and add yourself to your parent's list of children when you are popped.
  \code{Graphs/MST.java}
  
  \subsection{Topological Sort}
  Time complexity is $\bigO(|E| + |V|)$ and space complexity is $\bigO(|V|)$. You need to pop the resulting stack to get the nodes in the correct order, \textit{do not} loop over it/convert to list since that results in the reverse order.
  \code{Graphs/TopologicalSort.java}
  
  \subsection{Network Flow/Min Cut}
  Time complexity is $\bigO(|V||E|^2)$ and space complexity is $\bigO(|V|+|E|)$. Solves both max flow and min cut. If the graph is very large this can be improved to $\bigO(|E|^2 \log{C})$ (where C is the maximum flow). Find $\Delta$, the largest POT that is smaller than the largest flow out of $s$. Run the algorithm but only allow edges with a capacity of at least $\Delta$. When there are no more paths between $s$ and $t$ let $\Delta = \Delta / 2$ and repeat until $\Delta < 0$.
  \code{Graphs/NetworkFlow.java}
  
  \subsection{Hopcroft-Carp Algorithm}
  Time complexity is $\bigO(|E|\sqrt{|V|})$ and space complexity is $\bigO(|V|)$. Gives both a maximum bipartite matching and a minimum vertex cover. Can be converted to Maximum Independent Set by selecting all vertices not in the vertex cover.
  \code{Graphs/HopcroftCarp.java}
        
        
\section{Acieving AC on a solved problem}
    \subsection{WA}
        \begin{itemize}
        \item Check that minimal input passes.
        \item Can an int overflow?
        \item Reread the problem statement.
        \item Start creating small testcases with python.
        \item Does cout print with high enough precision?
        \item Abstract the implementation.
        \end{itemize}
    \subsection{TLE}
        \begin{itemize}
        \item Is the solution sanity checked?
        \item Use pypy instead of python.
        \item Rewrite in C++ or Java.
        \item Can we apply DP anywhere?
        \item To minimize penalty time you should create a worst case input (if easy) to test on.
        \end{itemize}
    \subsection{RTE}
        \begin{itemize}
        \item Recursion limit in python?
        \item Arrayindex out of bounds?
        \item Division by $0$?
        \item Modifying iterator while iterating over it?
        \item Not using a well definied operator for Collections.sort?
        \item If nothing makes sense and the end of the contest is approaching you 
            can binary search over where the error is with try-except.
        \end{itemize}
    \subsection{MLE}
        \begin{itemize}
        \item Create objects outside recursive function.
        \item Rewrite recursive solution to itterative with an own stack.
        \end{itemize}
        
\section{Running time}
The following table contains the number of elements that can be processed per second given the algorithm complexity in $n$.
\begin{center}
\begin{tabular}{lr}
Alg. Complexity & Input size/s \\ \hline
$\bigO(\log(n))$     & 2 \textasciicircum 100 000 000 \\
$\bigO(n)$           & 100 000 000 \\
$\bigO(n*\log(n))$   & 4 500 000 \\
$\bigO(n^2)$         & 10 000 \\
$\bigO(n^2*\log(n))$ & 3 000 \\
$\bigO(n^3)$         & 450 \\
$\bigO(2^n)$         & 26.5 \\
$\bigO(3^n)$         & 16.5 \\
$\bigO(n!)$          & 10
\end{tabular}
\end{center}



\end{multicols*}
\end{document}
