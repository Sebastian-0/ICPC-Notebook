\documentclass[8pt,a4paper,landscape,oneside]{amsart}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{multicol}
\usepackage{fancyhdr}

%\usepackage{booktabs}
%\usepackage{caption}
%\usepackage{color}
%\usepackage{float}
\usepackage{fullpage}
%\usepackage{subcaption}
%\usepackage[scaled]{beramono}
\usepackage{titling}
%\usepackage{datetime}
%\usepackage{enumitem}
%\usepackage{bm}

% Minted
\usepackage{minted}
\newcommand{\code}[1]{\inputminted[fontsize=\normalsize,baselinestretch=1]{java}{code/#1}}

\newcommand{\bigO}{\mathcal{O}}

\pagestyle{fancy}
\lhead{Flip the tables - Lund University}
\rhead{\thepage}
\cfoot{}
\setlength{\headheight}{15.2pt}
\setlength{\droptitle}{-20pt}
\posttitle{\par\end{center}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\begin{document}

\begin{multicols*}{3}
%\maketitle
\thispagestyle{fancy}
\vspace{-3em}

\tableofcontents
\section{Code Templates}
  \subsection{KattIO}
  \code{Kattio.java}
  
  
\section{Data Structures}
  \subsection{Binary Search}
  Time complexity is $\bigO(n \log(n))$ and space complexity is $\bigO(1)$.
  \code{Structures/BinarySearch.java}
  \subsection{Sorting}
  Time complexity is $\bigO(n \log(n))$ for both algorithms and space complexity is $\bigO(\log(n))$.
  \begin{itemize}
  \item \texttt{Collections.sort()} uses Merge Sort
  \item \texttt{Arrays.sort()} uses Quick Sort
  \end{itemize}
  
  \subsection{Quick Select}
  Time complexity is $\bigO(n)$ on average and $\bigO(n^2)$ in the worst case. The space complexity is $\bigO(\log(n))$.
  \code{Structures/QuickSelect.java}
  
  \subsection{Knuth-Morris-Pratt Algorithm}
  Time complexity is $\bigO(n)$ and space complexity is $\bigO(\log(n))$. Good when the alphabet is small (around 4-5 characters).
  \code{Structures/KMP.java}
  
  \subsection{Z-Array Algorithm}
  Time complexity is $\bigO(n)$ and space complexity is $\bigO(n)$. Good when the alphabet is large.
  \code{Structures/ZArray.java}
  
  \subsection{Fenwick tree}
  Time complexity is $\bigO(\log(n))$ for all operations and space complexity is $\bigO(1)$.
  \code{Structures/Fenwick.java}
  
  
\section{Graph Algorithms}
  \subsection{Graph definition}
  This graph class is used for the graph algorithms. Not all attributes of the classes are needed in all problems.
  \code{Graphs/Graph.java}  
  \subsection{Dijsktra's Algorithm}
  Time complexity is $\bigO(|E| \log{|V|})$ and space complexity is $\bigO(|V|)$.
  \code{Graphs/Dijkstras.java}
  
  \subsection{Bellman-Ford Algorithm}
  Time complexity is $\bigO(|E||V|)$ and space complexity is $\bigO(|V|)$.
  \code{Graphs/BellmanFord.java}
  
  \subsection{Floyd-Warshall Algorithm}
  Time complexity is $\bigO(|V|^3)$ and space complexity is $\bigO(|V|^2)$.
  \code{Graphs/FloydWarshall.java}
  
  \subsection{Prim's Algorithm}
  Time complexity is $\bigO(|E| \log{|V|})$ and space complexity is $\bigO(|V|)$.
  \code{Graphs/MST.java}
  
  \subsection{Topological Sort}
  Time complexity is $\bigO(|E| + |V|)$ and space complexity is $\bigO(|V|)$. You need to pop the resulting stack to get the nodes in the correct order, \textit{do not} loop over it/convert to list since that results in the reverse order. Running this on a graph with cycles yields an incorrect result.
  \code{Graphs/TopologicalSort.java}
  
  \subsection{Network Flow/Min Cut}
  Time complexity is $\bigO(|V||E|^2)$ and space complexity is $\bigO(|V|+|E|)$. Solves both max flow and min cut. If the graph is very large this can be improved to $\bigO(|E|^2 \log{C})$ (where C is the maximum flow). Find $\Delta$, the largest POT that is smaller than the largest flow out of $s$. Run the algorithm but only allow edges with a capacity of at least $\Delta$. When there are no more paths between $s$ and $t$ let $\Delta = \Delta / 2$ and repeat until $\Delta < 0$.
  \code{Graphs/NetworkFlow.java}
  
  \subsection{Hopcroft-Carp Algorithm}
  Time complexity is $\bigO(|E|\sqrt{|V|})$ and space complexity is $\bigO(|V|)$. Gives both a maximum bipartite matching and a minimum vertex cover. Can be converted to Maximum Independent Set by selecting all vertices not in the vertex cover.
  \code{Graphs/HopcroftCarp.java}
        
        
\section{Checking for errors}
  \subsection{Wrong Answer}
    \begin{itemize}
    \item Test minimal input
    \item Integer overflow?
    \item Double precision too low?
    \item Reread the problem statement
    \item Look for edge-cases
    \item Start creating small testcases
    \end{itemize}
  \subsection{Time Limit Exceeded}
    \begin{itemize}
    \item Is the time complexity checked?
    \item Is the output efficient?
    \item If written in python, rewrite in java?
    \item Can we apply DP anywhere?
    \item Create worst case input
    \end{itemize}
  \subsection{Runtime Error}
    \begin{itemize}
    \item Stack overflow?
    \item Index out of bounds?
    \item Division by $0$?
    \item Concurrent modification?
    \end{itemize}
  \subsection{Memory Limit Exceeded}
    \begin{itemize}
    \item Create objects outside recursive function
    \item Convert recursive functions to iterative with your own stack
    \end{itemize}
        
        
\section{Running time}
The following table contains the number of elements that can be processed per second given the algorithm complexity in $n$.
\begin{center}
\begin{tabular}{lr}
Alg. Complexity & Input size/s \\ \hline
$\bigO(\log(n))$     & 2 \textasciicircum 100 000 000 \\
$\bigO(n)$           & 100 000 000 \\
$\bigO(n*\log(n))$   & 4 500 000 \\
$\bigO(n^2)$         & 10 000 \\
$\bigO(n^2*\log(n))$ & 3 000 \\
$\bigO(n^3)$         & 450 \\
$\bigO(2^n)$         & 26.5 \\
$\bigO(3^n)$         & 16.5 \\
$\bigO(n!)$          & 10
\end{tabular}
\end{center}



\end{multicols*}
\end{document}
